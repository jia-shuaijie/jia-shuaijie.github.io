import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,o as e,a as t}from"./app-BXIyiqdS.js";const a={},n=t('<h1 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构"><span>数据结构</span></a></h1><h2 id="栈" tabindex="-1"><a class="header-anchor" href="#栈"><span>栈</span></a></h2><p>stack,又称为堆栈.</p><p>栈是限定仅在表尾进行插入和删除操作的线性表.</p><p>把允许插入和删除的一端称为栈顶,另一端称为栈底,不包含任何数据元素的栈称为空栈.</p><p>栈又称为先进后厨的线性表.</p><p>特点: 先进后出</p><ul><li>即存进去的元素,要将后面的元素取出后才能取出该元素.</li><li>栈的出入口都是栈的顶部位置.</li></ul><p>名词解释</p><ul><li>压栈: 存元素</li><li>弹栈: 取元素</li></ul><h2 id="队列" tabindex="-1"><a class="header-anchor" href="#队列"><span>队列</span></a></h2><p>简称队, 队列是一种特殊的线性表,是运算受到限制的一种线性表,只允许在表的一端进行插入,另一端进行删除元素的线性表.</p><p>队尾(rear) 是允许插入的一端.</p><p>队头(front) 是允许删除的一端.</p><p>空队列是不包含元素的空表.</p><p>特点: 先进先出</p><ul><li>存入的元素,要将它前面的元素取出后才能去除该元素.</li><li>队列的出入口各占一侧.</li></ul><h2 id="数组" tabindex="-1"><a class="header-anchor" href="#数组"><span>数组</span></a></h2><p>Array是有序元素序列,数组是在内存中开辟一段连续的空间,并在此空间中存放元素.</p><p>特点:</p><ul><li>查找元素快 <ul><li>通过索引快速访问指定位置的元素</li></ul></li><li>增删改查慢 <ul><li>指定索引位置增加元素: 需要新建一个新数组,将指定新元素存储在指定索引位置,再把原数组元素根据索引,复制到新数组对应的索引位置.</li><li>指定索引位置删除袁术: 需要创建一个新数组,把原数组元素根据索引,复制到新数组对应索引的位置,原数组中指定索引位置元素不复制到新数组中.</li></ul></li></ul><h2 id="链表" tabindex="-1"><a class="header-anchor" href="#链表"><span>链表</span></a></h2><p>linked list由一系列结点node(链表中每一个元素称为结点)组成结点可以在运行时动态生成。</p><p>每个结点包括两个部分:</p><ol><li>存储数据元素的数据域</li><li>存储下一个结点的地址指针域</li></ol><p>特点</p><ol><li>多个结点之间,通过地址进行连接。</li><li>查找元素慢: 想查找某个元素,需要通过连接的节点,依次向后查找指定元素</li><li>增删元素快: <ul><li>增加元素: 只需要修改连接下个元素的地址即可</li><li>删除元素: 只需要修改连接下个元素的地址即可。</li></ul></li></ol><p>链表有三类</p><ol><li>单向链表 <ul><li>在单向链表中, 右链表不知 左边数据时谁</li><li>如果要查询数据,那么需要从开始一直查到数据所在</li></ul></li><li>双向链表 <ul><li>双向链表 左边知道右边的数据是什么</li></ul></li><li>循环链表 <ul><li>开始链表的上一位时链表的最后一位, 而结束链表的下一位是开始链表的下一位</li></ul></li></ol><h2 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树"><span>红黑树</span></a></h2><p>二叉树:binary tree 是每个结点不超过2的有序树(tree) 。</p><p>简单的理解,就是一种类似于我们生活中树的结构,只不过每个结点上都最多只能有两个子结点.</p><p>二叉树是每个节点最多有两个子树的树结构。</p><p>顶上的叫根结点,两边被称作&quot;左子树&quot;和&quot;右子树&quot;。</p><p>红黑树本身就是一颗二叉查找树,将节点插入后,该树仍然是一颗二叉查找树.</p><p>也就意味着,树的键值仍然是有序的。</p><p>红黑树的约束:</p><ol><li>节点可以是红色的或者黑色的</li><li>根节点是黑色的</li><li>叶子节点(特指空节点)是黑色的</li><li>每个红色节点的子节点都是黑色的</li><li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</li></ol><p>特点: 速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍</p><h1 id="集合" tabindex="-1"><a class="header-anchor" href="#集合"><span>集合</span></a></h1><p>集合是java中提供的一种容器,可以用来存储多个数据,java 中集合都属于 java.util 包.</p><p>集合中顶级父接口有哪些?</p><ol><li><p>单列集合的顶级父接口 [ 单列集合同时会继承 Iterable(迭代器) ]: java.util.Collection</p></li><li><p>双列集合的顶级父接口: java.util.Map</p></li></ol><h2 id="单列集合" tabindex="-1"><a class="header-anchor" href="#单列集合"><span>单列集合</span></a></h2><h3 id="collection接口" tabindex="-1"><a class="header-anchor" href="#collection接口"><span>Collection接口</span></a></h3><p>Collection 所有单列集合的顶级父接口.</p><p>collection 中一些常见方法</p><ul><li>boolean add(E e): 把给定的对象添加到当前集合中 。</li><li>void clear(): 清空集合中所有的元素。</li><li>boolean remove(E e): 把给定的对象在当前集合中删除。</li><li>boolean contains(E e): 判断当前集合中是否包含给定的对象。</li><li>boolean isEmpty(): 判断当前集合是否为空。</li><li>int size(): 返回集合中元素的个数。</li><li>Object[] toArray(): 把集合中的元素,存储到数组中。</li></ul><h3 id="list接口" tabindex="-1"><a class="header-anchor" href="#list接口"><span>List接口</span></a></h3><p>特点</p><ul><li>它是一个元素存取有序的集合</li><li>它是一个带有索引的集合,通过索引就可以精确的操作集合中的元素(与数组的索引是一个道理)</li><li>集合中可以有重复的元素,通过元素的equals方法,来比较是否为重复的元素.</li></ul><p>常用方法</p><ul><li>boolean add(E e): 将指定的元素追加到此列表的末尾(可选操作)</li><li>void add(int index, E element): 将指定的元素,添加到该集合中的指定位置上。</li><li>E get(int index): 返回集合中指定位置的元素。</li><li>E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li>E set(int index, E element): 用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li><li>boolean contains​(Object o) 不管此列表中包含几个指定的元素都会返回 true;</li><li>boolean isEmpty(): 此列表中不包含任何元素时返回 true;</li></ul><p>List的实现类</p><ul><li>AbstractList</li><li>AbstractSequentialList</li><li>ArrayList (必须知道)</li><li>AttributeList</li><li>CopyOnWriteArrayList</li><li>LinkedList</li><li>RoleList</li><li>RoleUnresolvedList</li><li>Stack</li><li>Vector</li></ul><h4 id="linkedlist集合" tabindex="-1"><a class="header-anchor" href="#linkedlist集合"><span>LinkedList集合</span></a></h4><p>LinkedList 是 List 的实现类之一 <code>class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</code></p><p>继承 AbstractSequentialList,实现 List,Deque,Cloneable,Serializable</p><p>LinkedList 提供了很多首尾操作的方法,所以也可以作为堆栈或队列使用.</p><p>特有的方法</p><ul><li>void addFirst​(E e): 在此列表的开头插入指定的元素</li><li>void addLast​(E e): 将指定的元素追加到此列表的末尾。</li><li>E getFirst(): 返回此列表中的第一个元素。</li><li>E getLast(): 返回此列表中的最后一个元素。</li><li>E removeFirst(): 移除并返回此列表的第一个元素。</li><li>E removeLast(): 移除并返回此列表的最后一个元素。</li><li>E pop(): 从此列表所表示的堆栈处弹出一个元素。</li><li>void push(E e): 将元素推入此列表所表示的堆栈。</li><li>boolean isEmpty(): 如果列表不包含元素,则返回true。</li></ul><h3 id="set接口" tabindex="-1"><a class="header-anchor" href="#set接口"><span>Set接口</span></a></h3><p>它与Collection 接口中的方法基本一致,并没有对 Collection 接口进行功能上的扩充,只是比Collection 接口更加严格了.</p><p>与 List 接口不同的是, Set 接口中元素无序,并且都会以某种规则保证存入的元素不出现重复。</p><p>Set实现类</p><ul><li>AbstractSet</li><li>ConcurrentHashMap.KeySetVie</li><li>ConcurrentSkipListSet</li><li>CopyOnWriteArraySet</li><li>EnumSet</li><li>HashSet</li><li>JobStateReasons</li><li>LinkedHashSet</li><li>TreeSet</li></ul><h4 id="hashset实现类" tabindex="-1"><a class="header-anchor" href="#hashset实现类"><span>HashSet实现类</span></a></h4><p><code>class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable</code></p><p>继承 AbstractSet,实现 Set,Cloneable,Serializable</p><p>HashSet 是根据对象的哈希值来确定元素在集合中的存储位置,因此具有良好的存取和查找性能,保证元素唯一性的方式依赖于: hashCode 与 equals 方法。</p><p>HashSet集合存储数据的结构(哈希表)</p><ul><li>在JDK1.8之前,哈希表底层采用 数组+链表实现,即使用链表处理冲突,同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多,即hash值相等的元素较多时,通过key值依次查找的效率较低。而JDK1.8中,哈希表存储采用数组+链表+红黑树实现,当链表长度超过阈值(8)时,将链表转换为红黑树,这样大大减少了查找时间。</li><li>JDK1.8引入红黑树大程度优化了HashMap的性能,那么对于我们来讲保证HashSet集合元素的唯一,其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象,那么保证其唯一,就必须复写hashCode和equals方法建立属于当前对象的比较方式。</li></ul><p>HashSet存储自定义类型元素</p><ul><li>给HashSet中存放自定义类型元素时,需要重写对象中的hashCode和equals方法,建立自己的比较方式,才能保证HashSet集合中的对象唯一</li></ul><h2 id="双列集合" tabindex="-1"><a class="header-anchor" href="#双列集合"><span>双列集合</span></a></h2><h3 id="map-接口" tabindex="-1"><a class="header-anchor" href="#map-接口"><span>Map 接口</span></a></h3><p>双列集合的顶级父接口</p><p>Map集合是以键值对的形式存在, 而Map集合的键是不允许重复的!</p><p>哈希表[Map的工作原理]</p><ul><li>初始桶数量为 16 散列因子 0.75 当桶的数据存到75%后会对桶进行扩容一倍处理</li><li>两种特殊情况 <ul><li>哈希桶中的数据量大于8时,会从链表转换为红黑二叉树</li><li>哈希桶中的数据量小于6时,会从红黑二叉树转换为链表</li></ul></li></ul><p>实现类</p><ul><li>AbstractMap</li><li>Attributes</li><li>AuthProvider</li><li>ConcurrentHashMap</li><li>ConcurrentSkipListMap</li><li>EnumMap</li><li>HashMap</li><li>Hashtable</li><li>Headers</li><li>IdentityHashMap</li><li>LinkedHashMap</li><li>PrinterStateReasons</li><li>Properties</li><li>Provider</li><li>RenderingHints</li><li>ScriptObjectMirror</li><li>SimpleBindings</li><li>TabularDataSupport</li><li>TreeMap</li><li>UIDefaults</li><li>WeakHashMap</li></ul><p>HashMap/Hashtable/ConcurrentHashMap之间的区别</p><ul><li>HashMap: 线程不安全 效率高</li><li>Hashtable: 线程安全 效率低</li><li>ConcurrentHashMap: 线程安全 采用分段锁机制,保证线程安全,效率比较高</li><li>TreeMap: 顺序存储 是一个有序Map集合 是二叉树存储 LinkedHashMap,在HashMap和linkedSet中分别存储一份 有序存储</li></ul>',84),s=[n];function p(r,o){return e(),i("div",null,s)}const c=l(a,[["render",p],["__file","数据结构与集合.html.vue"]]),u=JSON.parse('{"path":"/dev/java/base/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88.html","title":"数据结构","lang":"zh-CN","frontmatter":{"icon":"book","date":"2024-07-22T00:00:00.000Z","category":["后端开发","java"],"tag":["java"],"order":1,"description":"数据结构 栈 stack,又称为堆栈. 栈是限定仅在表尾进行插入和删除操作的线性表. 把允许插入和删除的一端称为栈顶,另一端称为栈底,不包含任何数据元素的栈称为空栈. 栈又称为先进后厨的线性表. 特点: 先进后出 即存进去的元素,要将后面的元素取出后才能取出该元素. 栈的出入口都是栈的顶部位置. 名词解释 压栈: 存元素 弹栈: 取元素 队列 简称队,...","head":[["meta",{"property":"og:url","content":"https://jia-shuaijie.github.io/dev/java/base/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88.html"}],["meta",{"property":"og:site_name","content":"黑色的小火苗"}],["meta",{"property":"og:title","content":"数据结构"}],["meta",{"property":"og:description","content":"数据结构 栈 stack,又称为堆栈. 栈是限定仅在表尾进行插入和删除操作的线性表. 把允许插入和删除的一端称为栈顶,另一端称为栈底,不包含任何数据元素的栈称为空栈. 栈又称为先进后厨的线性表. 特点: 先进后出 即存进去的元素,要将后面的元素取出后才能取出该元素. 栈的出入口都是栈的顶部位置. 名词解释 压栈: 存元素 弹栈: 取元素 队列 简称队,..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-22T13:09:27.000Z"}],["meta",{"property":"article:author","content":"黑色的小火苗"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:published_time","content":"2024-07-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-22T13:09:27.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据结构\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-07-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-22T13:09:27.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"黑色的小火苗\\",\\"url\\":\\"https://jia-shuaijie.github.io\\"}]}"]]},"headers":[{"level":2,"title":"栈","slug":"栈","link":"#栈","children":[]},{"level":2,"title":"队列","slug":"队列","link":"#队列","children":[]},{"level":2,"title":"数组","slug":"数组","link":"#数组","children":[]},{"level":2,"title":"链表","slug":"链表","link":"#链表","children":[]},{"level":2,"title":"红黑树","slug":"红黑树","link":"#红黑树","children":[]},{"level":2,"title":"单列集合","slug":"单列集合","link":"#单列集合","children":[{"level":3,"title":"Collection接口","slug":"collection接口","link":"#collection接口","children":[]},{"level":3,"title":"List接口","slug":"list接口","link":"#list接口","children":[{"level":4,"title":"LinkedList集合","slug":"linkedlist集合","link":"#linkedlist集合","children":[]}]},{"level":3,"title":"Set接口","slug":"set接口","link":"#set接口","children":[{"level":4,"title":"HashSet实现类","slug":"hashset实现类","link":"#hashset实现类","children":[]}]}]},{"level":2,"title":"双列集合","slug":"双列集合","link":"#双列集合","children":[{"level":3,"title":"Map 接口","slug":"map-接口","link":"#map-接口","children":[]}]}],"git":{"createdTime":1721653767000,"updatedTime":1721653767000,"contributors":[{"name":"黑色的小火苗","email":"jiashuaijie@yeah.net","commits":1}]},"readingTime":{"minutes":8.16,"words":2447},"filePathRelative":"dev/java/base/数据结构与集合.md","localizedDate":"2024年7月22日","excerpt":"\\n<h2>栈</h2>\\n<p>stack,又称为堆栈.</p>\\n<p>栈是限定仅在表尾进行插入和删除操作的线性表.</p>\\n<p>把允许插入和删除的一端称为栈顶,另一端称为栈底,不包含任何数据元素的栈称为空栈.</p>\\n<p>栈又称为先进后厨的线性表.</p>\\n<p>特点: 先进后出</p>\\n<ul>\\n<li>即存进去的元素,要将后面的元素取出后才能取出该元素.</li>\\n<li>栈的出入口都是栈的顶部位置.</li>\\n</ul>\\n<p>名词解释</p>\\n<ul>\\n<li>压栈: 存元素</li>\\n<li>弹栈: 取元素</li>\\n</ul>\\n<h2>队列</h2>\\n<p>简称队, 队列是一种特殊的线性表,是运算受到限制的一种线性表,只允许在表的一端进行插入,另一端进行删除元素的线性表.</p>","autoDesc":true}');export{c as comp,u as data};
