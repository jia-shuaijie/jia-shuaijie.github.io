import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,a as e}from"./app-QGmvmOnY.js";const i={},l=e(`<h1 id="微服务" tabindex="-1"><a class="header-anchor" href="#微服务"><span>微服务</span></a></h1><p>简介</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>业务系统实施服务化改造之后,原本共享的业务被拆分形成可复⽤的服务,可以在最⼤程度上避免共享业务的重复建设、资源连接瓶颈瓶颈等问题.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>微服务就是这样⼀种解决⽅案,从名字上来看,⾯向服务(SOA)和微服务本质上都是服务化思想的⼀种体现。如果SOA是⾯向服务开发的思想的雏形,那么微服务就是针对可重⽤业务服务的更进⼀步优化,我们可以把SOA看成微服务的超集,⼀但服务规模扩⼤就意味着服务的构建、发布、运维的复杂度也会成倍增加,所以实施微服务的前提是软件交付链路及基础设施的成熟化。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>因此微服务在我看来并不是⼀个新的概念,他本质上是服务化思想的最佳实践⽅向。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>由于SOA和微服务两者的关注点不⼀样,造成了这两者有⾮常⼤的区别:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    SOA关注的是服务的重⽤性及解决信息孤岛问题。</span></span>
<span class="line"><span>    微服务关注的是解耦,虽然解耦和可重⽤性从特定的⻆度来看是⼀样的,但本质上是有区别的,解耦是降低业务之间的耦合度,⽽重⽤性关注的是服务的复⽤。</span></span>
<span class="line"><span>    微服务会更多地关注在DevOps的持续交付上,因为服务粒度细化之后使得开发运维变得更加重要,因此微服务与容器化技术的结合更加紧密。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://i.jpg.dog/0f284481d6391e005b3604c099c07ec8.png" alt="微服务" tabindex="0" loading="lazy"><figcaption>微服务</figcaption></figure><p>如图1-4所示,将每个具体的业务服务构成可独⽴运⾏的微服务,每个微服务只关注某个特定的功能,服务之间采⽤轻量级通信机制REST API进⾏通信。</p><p>细⼼的读者会发现SOA中的服务和微服务架构中的服务粒度是⼀样的,不是说SOA是微服务的超集吗？</p><p>其实我们可以把⽤户服务拆分的更细,⽐如⽤户注册服务、⽤户鉴权服务等。实际上,微服务到底要拆分到多⼤的粒度没有统⼀的标准,更多的时候是需要在粒度和团队之间找平衡的,微服务的粒度越⼩,服务独⽴性带来的好处就越多,但是管理⼤量的微服务也会越复杂。</p><p>微服务框架功能</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>注册中⼼</span></span>
<span class="line"><span>    服务提供者和消费者,能够从注册中⼼注册和得到服务信息。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>配置中⼼</span></span>
<span class="line"><span>    在微服务架构中设计服务较多需要对于配置⽂件统⼀管理。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>服务链路追踪</span></span>
<span class="line"><span>    对于服务之间的负载调⽤,要能通过链路追踪,得到具体参与者,调⽤链路出现问题能够快速定位。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>负载均衡</span></span>
<span class="line"><span>    服务调⽤服务会采⽤⼀定的负载均衡策略,来保证服务的⾼可⽤。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>服务容错</span></span>
<span class="line"><span>    通过熔断、降级服务容错策略,对系统进⾏有效的保护.</span></span>
<span class="line"><span>    降级是在服务或依赖的服务异常时,返回保底数据.</span></span>
<span class="line"><span>    熔断是指依赖服务多次失效,则熔断器打开,不再尝试调⽤,直接返回降级信息。</span></span>
<span class="line"><span>    熔断后,定期探测依赖服务可⽤性,若恢复则恢复调⽤。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>服务⽹关</span></span>
<span class="line"><span>    ⽤户请求过载时进⾏限流、排队、过载保护、⿊⽩名单、异常⽤户过滤拦截等都可以通过服务⽹关实现。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>服务发布与回滚</span></span>
<span class="line"><span>    蓝绿部署、灰度、AB Test等发布策略,可快速回滚应⽤。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>服务动态伸缩、容器化</span></span>
<span class="line"><span>    根据服务负载情况,可快速⼿动或⾃动进⾏节点增加和减少。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="spring-cloud" tabindex="-1"><a class="header-anchor" href="#spring-cloud"><span>spring Cloud</span></a></h1><p>简介</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>Spring Cloud是Spring提供的微服务框架。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>它利⽤Spring Boot的开发特性简化了微服务开发的复杂性,如服务发现注册、配置中⼼、消息总线、负载均衡、断路器、数据监控等,这些⼯作都可以借助Spring Boot的开发⻛格做到⼀键启动和部署。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Spring Cloud的⽬标是通过⼀系列组件,帮助开发者迅速构件⼀个分布式系统,Spring Cloud 是通过包装其它公司产品来实现的,⽐如Spring Cloud整合了开源的Netflix很多产品。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Spring Cloud提供了微服务治理的诸多组件,例如服务注册和发现、配置中⼼、熔断器、智能路由、微代理、控制总线、全局锁、分布式会话等。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>spring cloud 版本</p><table><thead><tr><th style="text-align:center;">Spring Cloud</th><th style="text-align:center;">Spring Boot</th></tr></thead><tbody><tr><td style="text-align:center;">2020.0.x aka Ilford</td><td style="text-align:center;">2.4.x, 2.5.x (Starting with 2020.0.3)</td></tr><tr><td style="text-align:center;">Hoxton</td><td style="text-align:center;">2.2.x, 2.3.x (Starting with SR5)</td></tr><tr><td style="text-align:center;">Greenwich</td><td style="text-align:center;">2.1.x</td></tr><tr><td style="text-align:center;">Finchley</td><td style="text-align:center;">2.0.x</td></tr><tr><td style="text-align:center;">Edgware</td><td style="text-align:center;">1.5.x</td></tr><tr><td style="text-align:center;">Dalston</td><td style="text-align:center;">1.5.x</td></tr></tbody></table><p>官⽹对版本进⾏如下解释</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>Spring Cloud Dalston, Edgware, Finchley, and Greenwich have all reached end of lifestatus and are no longer supported. Spring Cloud Dalston、Edgware、Finchley 和 Greenwich 都已达到⽣命周期终⽌状态,不再受⽀持</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,16),t=[l];function p(d,r){return a(),s("div",null,t)}const v=n(i,[["render",p],["__file","微服务.html.vue"]]),h=JSON.parse('{"path":"/dev/java/springCloud/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html","title":"微服务","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-07-22T00:00:00.000Z","category":["后端开发","spring系列"],"tag":["java"],"description":"微服务 简介 微服务微服务 如图1-4所示,将每个具体的业务服务构成可独⽴运⾏的微服务,每个微服务只关注某个特定的功能,服务之间采⽤轻量级通信机制REST API进⾏通信。 细⼼的读者会发现SOA中的服务和微服务架构中的服务粒度是⼀样的,不是说SOA是微服务的超集吗？ 其实我们可以把⽤户服务拆分的更细,⽐如⽤户注册服务、⽤户鉴权服务等。实际上,微服务到...","head":[["meta",{"property":"og:url","content":"https://jia-shuaijie.github.io/dev/java/springCloud/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html"}],["meta",{"property":"og:site_name","content":"黑色的小火苗"}],["meta",{"property":"og:title","content":"微服务"}],["meta",{"property":"og:description","content":"微服务 简介 微服务微服务 如图1-4所示,将每个具体的业务服务构成可独⽴运⾏的微服务,每个微服务只关注某个特定的功能,服务之间采⽤轻量级通信机制REST API进⾏通信。 细⼼的读者会发现SOA中的服务和微服务架构中的服务粒度是⼀样的,不是说SOA是微服务的超集吗？ 其实我们可以把⽤户服务拆分的更细,⽐如⽤户注册服务、⽤户鉴权服务等。实际上,微服务到..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://i.jpg.dog/0f284481d6391e005b3604c099c07ec8.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-22T13:09:27.000Z"}],["meta",{"property":"article:author","content":"黑色的小火苗"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:published_time","content":"2024-07-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-22T13:09:27.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"微服务\\",\\"image\\":[\\"https://i.jpg.dog/0f284481d6391e005b3604c099c07ec8.png\\"],\\"datePublished\\":\\"2024-07-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-22T13:09:27.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"黑色的小火苗\\",\\"url\\":\\"https://jia-shuaijie.github.io\\"}]}"]]},"headers":[],"git":{"createdTime":1721653767000,"updatedTime":1721653767000,"contributors":[{"name":"黑色的小火苗","email":"jiashuaijie@yeah.net","commits":1}]},"readingTime":{"minutes":4.06,"words":1218},"filePathRelative":"dev/java/springCloud/微服务.md","localizedDate":"2024年7月22日","excerpt":"\\n<p>简介</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes github-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>业务系统实施服务化改造之后,原本共享的业务被拆分形成可复⽤的服务,可以在最⼤程度上避免共享业务的重复建设、资源连接瓶颈瓶颈等问题.</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>微服务就是这样⼀种解决⽅案,从名字上来看,⾯向服务(SOA)和微服务本质上都是服务化思想的⼀种体现。如果SOA是⾯向服务开发的思想的雏形,那么微服务就是针对可重⽤业务服务的更进⼀步优化,我们可以把SOA看成微服务的超集,⼀但服务规模扩⼤就意味着服务的构建、发布、运维的复杂度也会成倍增加,所以实施微服务的前提是软件交付链路及基础设施的成熟化。</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>因此微服务在我看来并不是⼀个新的概念,他本质上是服务化思想的最佳实践⽅向。</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>由于SOA和微服务两者的关注点不⼀样,造成了这两者有⾮常⼤的区别:</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    SOA关注的是服务的重⽤性及解决信息孤岛问题。</span></span>\\n<span class=\\"line\\"><span>    微服务关注的是解耦,虽然解耦和可重⽤性从特定的⻆度来看是⼀样的,但本质上是有区别的,解耦是降低业务之间的耦合度,⽽重⽤性关注的是服务的复⽤。</span></span>\\n<span class=\\"line\\"><span>    微服务会更多地关注在DevOps的持续交付上,因为服务粒度细化之后使得开发运维变得更加重要,因此微服务与容器化技术的结合更加紧密。</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{v as comp,h as data};
