import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as s,a}from"./app-QGmvmOnY.js";const n={},l=a(`<h1 id="spring-mvc" tabindex="-1"><a class="header-anchor" href="#spring-mvc"><span>Spring MVC</span></a></h1><h2 id="组件" tabindex="-1"><a class="header-anchor" href="#组件"><span>组件</span></a></h2><h3 id="dispatcherservlet" tabindex="-1"><a class="header-anchor" href="#dispatcherservlet"><span>DispatcherServlet</span></a></h3><p>前端控制器,也称为中央控制器或者核心控制器。</p><p>用户请求的入口控制器,它就相当于 mvc 模式中的c,DispatcherServlet 是整个流程控制的中心,相当于是 SpringMVC 的大脑,由它调用其它组件处理用户的请求,DispatcherServlet 的存在降低了组件之间的耦合性。</p><p>SpringMVC框架提供的该核心控制器需要我们在web.xml文件中配置。</p><h3 id="handlermapping" tabindex="-1"><a class="header-anchor" href="#handlermapping"><span>HandlerMapping</span></a></h3><p>处理器映射器 HandlerMapping也是控制器,派发请求的控制器。</p><p>我们不需要自己控制该类,但是他是springmvc运转历程中的重要的一个控制器。</p><p>HandlerMapping负责根据用户请求找到 Handler 即处理器(也就是我们所说的 Controller),SpringMVC 提供了不同的映射器实现不同的映射方式,</p><h3 id="handler" tabindex="-1"><a class="header-anchor" href="#handler"><span>Handler</span></a></h3><p>处理器 Handler 是继 DispatcherServlet 前端控制器的后端控制器,在DispatcherServlet 的控制下 Handler 对具体的用户请求进行处理。</p><p>由于 Handler 涉及到具体的用户业务请求,所以一般情况需要程序员根据业务需求开发 Handler。(这里所说的 Handler 就是指我们的 Controller)</p><h3 id="handladapter" tabindex="-1"><a class="header-anchor" href="#handladapter"><span>HandlAdapter</span></a></h3><p>处理器适配器 通过 HandlerAdapter 对处理器进行执行,这是适配器模式的应用,通过扩展处理器适配器,支持更多类型的处理器,调用处理器传递参数等工作。</p><h3 id="viewresolver" tabindex="-1"><a class="header-anchor" href="#viewresolver"><span>ViewResolver</span></a></h3><p>视图解析器 ViewResolver 负责将处理结果生成 View 视图,ViewResolver 首先根据逻辑视图名解析成物理视图名称,即具体的页面地址,再生成 View 视图对象,最后对 View 进行渲染将处理结果通过页面展示给用户。</p><p>SpringMVC 框架提供了很多的 View 视图类型,包括:jstlView、freemarkerView、pdfView 等。</p><h2 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理"><span>工作原理</span></a></h2><ol><li>用户在浏览器中访问相应网页时,浏览器会向服务器发送一个请求,此时服务器中接收此请求的时前端控制器<code>DispatcherServlet</code></li><li>前端控制器<code>DispatcherServlet</code>接收到此请求后,像Spring中的映射器发起请求<code>HandlerMapping</code>中查询对应的处理类</li><li>映射器找到相应的处理类时,将结果返回给前端控制器<code>DispatCherServlet</code>,此时前端控制会去找处理适配器<code>HandlerAdaptor</code></li><li>处理适配器接收到来自前端控制器<code>DispathCherServlet</code>后,对相应的处理器发起处理</li><li>相应的处理器类接收到指令后,找到对应方法进行执行</li><li>最终将执行结果返回给处理适配器<code>HandlerAdaptor</code>. [ 返回的结果可以是 modelAndView也可以是其他 ]</li><li>处理适配器接收到返回的结果后,将结果直接返回给前端控制器<code>DispathCherServlet</code></li><li>前端控制器接收到来自处理适配器的结果后,将结果交给视图解析器<code>ViewResolver</code>进行解析</li><li>视图解析器<code>ViewResolver</code>解析完成后将视图地址以及携带的数据返回给前端控制器</li><li>前端控制接收到视图地址和数据后,请求相应的视图,拿到对应的视图</li><li>最终将视图和数据反馈给用户请求的浏览器.</li></ol><h2 id="注解" tabindex="-1"><a class="header-anchor" href="#注解"><span>注解</span></a></h2><h3 id="controller" tabindex="-1"><a class="header-anchor" href="#controller"><span>@Controller</span></a></h3><p>和在 spring 中是一样的,都是交给容器来创建对象,只不过在 springmvc中默认返回的是页面.</p><p>如果在这个注解的类中想要返回对象,需要在方法上添加 <code>@ResponseBody</code> 注解.</p><h3 id="responsebody" tabindex="-1"><a class="header-anchor" href="#responsebody"><span>@ResponseBody</span></a></h3><p>可以添加到方法上,表示当前方法的返回值是对象,而不是转发页面</p><h3 id="restcontroller" tabindex="-1"><a class="header-anchor" href="#restcontroller"><span>@RestController</span></a></h3><p>这个注解可以理解为 @Controller 和 @ResponseBody 的组合.使用这个注解后,在当前类中,默认返回的是对象而不是请求或转发的页面.如果使用这个注解后想要转发页面,需要使用 ModelAndView 进行封装才可以转发.</p><h3 id="requestmapping" tabindex="-1"><a class="header-anchor" href="#requestmapping"><span>RequestMapping</span></a></h3><p>该注解可以定义在类上,也可以定义方法上,但是含义不同。</p><p>在类上时类似与一级请求,如果这个类处理的请求方法是 &quot;/user/add&quot;,&quot;/user/update&quot;这种就可以把 user 提取到类上作为一级请求使用.</p><p>在方法上时,如果有一级请求的情况下,类似与二级请求也就是 上面示例中 user 后面不同的请求路径.在方法上时不指定 method 时是所有类型的请求都会进行处理.</p><p>method 属性是由 RequestMethod 进行限定的,也就是 method 只能使用 RequestMethod 枚举类中的方法.</p><p><code>@GetMapping/@PostMapping/@PutMapping</code> 都是 <code>@RequestMapping</code> 的延申标签,分别对应各个请求.</p><h2 id="自定义拦截器" tabindex="-1"><a class="header-anchor" href="#自定义拦截器"><span>自定义拦截器</span></a></h2><p>自定义拦截器需要实现 HandlerInterceptor 接口.</p><h3 id="handlerinterceptor接口" tabindex="-1"><a class="header-anchor" href="#handlerinterceptor接口"><span>HandlerInterceptor接口</span></a></h3><h4 id="prehandle" tabindex="-1"><a class="header-anchor" href="#prehandle"><span>preHandle</span></a></h4><p>该方法在处理器方法执行之前执行。</p><p>返回值为boolean,若为true,则紧接着会执行处理器方法,且会将afterCompletion() 方法放入到一个专门的方法栈中等待执行。</p><h4 id="posthandle" tabindex="-1"><a class="header-anchor" href="#posthandle"><span>postHandle</span></a></h4><p>该方法在处理器方法执行之后执行。</p><p>处理器方法若最终未被执行,则该方法不会执行。</p><p>由于该方法是在处理器方法执行完后执行,且该方法参数中包含 ModelAndView,所以该方法可以修改处理器方法的处理结果数据,且可以修改跳转方向。</p><h4 id="aftercompletion" tabindex="-1"><a class="header-anchor" href="#aftercompletion"><span>afterCompletion</span></a></h4><p>当 preHandle()方法返回true时,会将该方法放到专门的方法栈中,等到对请求进行响应的所工作完成之后才执行该方法。 即该方法是在前端控制器渲染(数据填充)了响应页面之后执行的,此时对ModelAndView再操作也对响应无济于事。</p><p>最后执行的方法,清除资源,例如在Controller方法中加入数据</p><h3 id="在配置文件中配置" tabindex="-1"><a class="header-anchor" href="#在配置文件中配置"><span>在配置文件中配置</span></a></h3><div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" data-title="xml" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">mvc:interceptors</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">&lt;!-- 这里可以同时配置多个拦截器,配置的顺序就是拦截器的拦截顺序 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">mvc:interceptor</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    &lt;!-- 拦截器要拦截的请求路径 拦截所有用/** --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">mvc:mapping</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;"> path</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;/**&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">/&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    &lt;!-- 指定干活的拦截器 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">bean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;com.blackFire.interceptor.MyInterceptor2&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;myInterceptor&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">bean</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">mvc:interceptor</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">mvc:interceptor</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    &lt;!-- 拦截器要拦截的请求路径 拦截所有用/** --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">mvc:mapping</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;"> path</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;/**&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">/&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    &lt;!-- 指定干活的拦截器 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">bean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;com.blackFire.interceptor.MyInterceptor2&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;myInterceptor2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">bean</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">mvc:interceptor</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">mvc:interceptors</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">&lt;!--</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    如果有多个拦截器的时候:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        preHandle: 按照配置前后顺序执行</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        postHandle: 按照配置前后逆序执行</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        afterCompletion: 按照配置前后逆序执行</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> --&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,49),t=[l];function r(p,h){return s(),e("div",null,t)}const c=i(n,[["render",r],["__file","springmvc.html.vue"]]),k=JSON.parse('{"path":"/dev/java/spring%E7%B3%BB%E5%88%97/springmvc.html","title":"Spring MVC","lang":"zh-CN","frontmatter":{"icon":"book","date":"2024-06-26T00:00:00.000Z","category":["后端开发","spring系列"],"tag":["java"],"excerpt":false,"headerDepth":5,"order":2,"description":"Spring MVC 组件 DispatcherServlet 前端控制器,也称为中央控制器或者核心控制器。 用户请求的入口控制器,它就相当于 mvc 模式中的c,DispatcherServlet 是整个流程控制的中心,相当于是 SpringMVC 的大脑,由它调用其它组件处理用户的请求,DispatcherServlet 的存在降低了组件之间的耦合...","head":[["meta",{"property":"og:url","content":"https://jia-shuaijie.github.io/dev/java/spring%E7%B3%BB%E5%88%97/springmvc.html"}],["meta",{"property":"og:site_name","content":"黑色的小火苗"}],["meta",{"property":"og:title","content":"Spring MVC"}],["meta",{"property":"og:description","content":"Spring MVC 组件 DispatcherServlet 前端控制器,也称为中央控制器或者核心控制器。 用户请求的入口控制器,它就相当于 mvc 模式中的c,DispatcherServlet 是整个流程控制的中心,相当于是 SpringMVC 的大脑,由它调用其它组件处理用户的请求,DispatcherServlet 的存在降低了组件之间的耦合..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-27T08:40:22.000Z"}],["meta",{"property":"article:author","content":"黑色的小火苗"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:published_time","content":"2024-06-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-27T08:40:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Spring MVC\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-06-26T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-27T08:40:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"黑色的小火苗\\",\\"url\\":\\"https://jia-shuaijie.github.io\\"}]}"]]},"headers":[{"level":2,"title":"组件","slug":"组件","link":"#组件","children":[{"level":3,"title":"DispatcherServlet","slug":"dispatcherservlet","link":"#dispatcherservlet","children":[]},{"level":3,"title":"HandlerMapping","slug":"handlermapping","link":"#handlermapping","children":[]},{"level":3,"title":"Handler","slug":"handler","link":"#handler","children":[]},{"level":3,"title":"HandlAdapter","slug":"handladapter","link":"#handladapter","children":[]},{"level":3,"title":"ViewResolver","slug":"viewresolver","link":"#viewresolver","children":[]}]},{"level":2,"title":"工作原理","slug":"工作原理","link":"#工作原理","children":[]},{"level":2,"title":"注解","slug":"注解","link":"#注解","children":[{"level":3,"title":"@Controller","slug":"controller","link":"#controller","children":[]},{"level":3,"title":"@ResponseBody","slug":"responsebody","link":"#responsebody","children":[]},{"level":3,"title":"@RestController","slug":"restcontroller","link":"#restcontroller","children":[]},{"level":3,"title":"RequestMapping","slug":"requestmapping","link":"#requestmapping","children":[]}]},{"level":2,"title":"自定义拦截器","slug":"自定义拦截器","link":"#自定义拦截器","children":[{"level":3,"title":"HandlerInterceptor接口","slug":"handlerinterceptor接口","link":"#handlerinterceptor接口","children":[{"level":4,"title":"preHandle","slug":"prehandle","link":"#prehandle","children":[]},{"level":4,"title":"postHandle","slug":"posthandle","link":"#posthandle","children":[]},{"level":4,"title":"afterCompletion","slug":"aftercompletion","link":"#aftercompletion","children":[]}]},{"level":3,"title":"在配置文件中配置","slug":"在配置文件中配置","link":"#在配置文件中配置","children":[]}]}],"git":{"createdTime":1719477622000,"updatedTime":1719477622000,"contributors":[{"name":"黑色的小火苗","email":"jiashuaijie@yeah.net","commits":1}]},"readingTime":{"minutes":5.48,"words":1645},"filePathRelative":"dev/java/spring系列/springmvc.md","localizedDate":"2024年6月26日","excerpt":"\\n<h2>组件</h2>\\n<h3>DispatcherServlet</h3>\\n<p>前端控制器,也称为中央控制器或者核心控制器。</p>\\n<p>用户请求的入口控制器,它就相当于 mvc 模式中的c,DispatcherServlet 是整个流程控制的中心,相当于是 SpringMVC 的大脑,由它调用其它组件处理用户的请求,DispatcherServlet 的存在降低了组件之间的耦合性。</p>\\n<p>SpringMVC框架提供的该核心控制器需要我们在web.xml文件中配置。</p>\\n<h3>HandlerMapping</h3>\\n<p>处理器映射器 HandlerMapping也是控制器,派发请求的控制器。</p>","autoDesc":true}');export{c as comp,k as data};
